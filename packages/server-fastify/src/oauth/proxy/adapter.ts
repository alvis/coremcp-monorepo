/**
 * @module oauth/proxy/adapter
 * @description Storage adapter interfaces for the OAuth proxy following
 * node-oidc-provider's adapter pattern for consistency and extensibility.
 */

/**
 * Registered OAuth client stored in the proxy's local registry.
 * Clients register with the proxy, which then uses proxy credentials
 * to communicate with the external authorization server.
 */
export interface ProxyClient {
  /** unique client identifier generated by the proxy */
  client_id: string;
  /** hashed client secret (never store plaintext) */
  client_secret_hash: string;
  /** human-readable client name */
  client_name?: string;
  /** allowed redirect URIs for OAuth callbacks */
  redirect_uris: string[];
  /** supported grant types (default: authorization_code) */
  grant_types: string[];
  /** supported response types (default: code) */
  response_types: string[];
  /** token endpoint authentication method */
  token_endpoint_auth_method: string;
  /** requested OAuth scopes */
  scope?: string;
  /** client creation timestamp in milliseconds */
  created_at: number;
  /** optional client metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Authorization code mapping data.
 * Maps authorization codes to the local client that initiated the flow.
 */
export interface AuthCodeMapping {
  /** local client ID that initiated the authorization */
  clientId: string;
  /** original redirect URI from the client */
  redirectUri: string;
  /** PKCE code challenge (for validation at proxy level) */
  codeChallenge?: string;
  /** PKCE challenge method (S256 or plain) */
  codeChallengeMethod?: string;
  /** original scopes requested */
  scope?: string;
  /** timestamp when the code was issued */
  issuedAt: number;
  /** expiry timestamp in milliseconds */
  expiresAt: number;
}

/**
 * Token mapping data.
 * Maps tokens (hashed) to local client IDs for introspection enrichment.
 */
export interface TokenMapping {
  /** local client ID that owns this token */
  clientId: string;
  /** token type (access_token or refresh_token) */
  tokenType: 'access_token' | 'refresh_token';
  /** timestamp when the token was issued */
  issuedAt: number;
  /** expiry timestamp in milliseconds (optional, for cleanup) */
  expiresAt?: number;
}

/**
 * Storage adapter interface for the OAuth proxy.
 * Follows node-oidc-provider's adapter pattern with methods for
 * find, upsert, destroy, and consume operations.
 */
export interface ProxyStorageAdapter {
  // client operations //

  /**
   * finds a client by ID.
   * @param clientId the client identifier
   * @returns the client or null if not found
   */
  findClient(clientId: string): Promise<ProxyClient | null>;

  /**
   * stores or updates a client.
   * @param clientId the client identifier
   * @param client the client data to store
   */
  upsertClient(clientId: string, client: ProxyClient): Promise<void>;

  /**
   * deletes a client.
   * @param clientId the client identifier
   */
  destroyClient(clientId: string): Promise<void>;

  // authorization code mapping operations //

  /**
   * finds an authorization code mapping.
   * @param code the authorization code
   * @returns the mapping or null if not found
   */
  findAuthCodeMapping(code: string): Promise<AuthCodeMapping | null>;

  /**
   * stores an authorization code mapping.
   * @param code the authorization code
   * @param mapping the mapping data
   */
  upsertAuthCodeMapping(code: string, mapping: AuthCodeMapping): Promise<void>;

  /**
   * retrieves and removes an authorization code mapping (single-use).
   * @param code the authorization code
   * @returns the mapping or null if not found/already consumed
   */
  consumeAuthCodeMapping(code: string): Promise<AuthCodeMapping | null>;

  // token mapping operations //

  /**
   * finds a token mapping by hashed token.
   * @param tokenHash hash of the token
   * @returns the mapping or null if not found
   */
  findTokenMapping(tokenHash: string): Promise<TokenMapping | null>;

  /**
   * stores a token mapping.
   * @param tokenHash hash of the token
   * @param mapping the mapping data
   */
  upsertTokenMapping(tokenHash: string, mapping: TokenMapping): Promise<void>;

  /**
   * deletes a token mapping.
   * @param tokenHash hash of the token
   */
  destroyTokenMapping(tokenHash: string): Promise<void>;

  // maintenance operations //

  /**
   * cleans up expired mappings.
   * @returns number of items cleaned up
   */
  cleanupExpired?(): Promise<number>;
}

/**
 * In-memory implementation of the proxy storage adapter.
 * Suitable for development and testing. For production, use a
 * persistent storage backend (Redis, PostgreSQL, etc.).
 */
export class MemoryProxyStorageAdapter implements ProxyStorageAdapter {
  readonly #clients = new Map<string, ProxyClient>();
  readonly #authCodeMappings = new Map<string, AuthCodeMapping>();
  readonly #tokenMappings = new Map<string, TokenMapping>();

  /**
   * finds a client by ID.
   * @param clientId the client identifier
   * @returns the client or null if not found
   */
  public async findClient(clientId: string): Promise<ProxyClient | null> {
    return this.#clients.get(clientId) ?? null;
  }

  /**
   * stores or updates a client.
   * @param clientId the client identifier
   * @param client the client data to store
   */
  public async upsertClient(
    clientId: string,
    client: ProxyClient,
  ): Promise<void> {
    this.#clients.set(clientId, client);
  }

  /**
   * deletes a client.
   * @param clientId the client identifier
   */
  public async destroyClient(clientId: string): Promise<void> {
    this.#clients.delete(clientId);
  }

  /**
   * finds an authorization code mapping.
   * @param code the authorization code
   * @returns the mapping or null if not found
   */
  public async findAuthCodeMapping(
    code: string,
  ): Promise<AuthCodeMapping | null> {
    const mapping = this.#authCodeMappings.get(code);

    if (!mapping) {
      return null;
    }

    // check expiry
    if (Date.now() > mapping.expiresAt) {
      this.#authCodeMappings.delete(code);

      return null;
    }

    return mapping;
  }

  /**
   * stores an authorization code mapping.
   * @param code the authorization code
   * @param mapping the mapping data
   */
  public async upsertAuthCodeMapping(
    code: string,
    mapping: AuthCodeMapping,
  ): Promise<void> {
    this.#authCodeMappings.set(code, mapping);
  }

  /**
   * retrieves and removes an authorization code mapping (single-use).
   * @param code the authorization code
   * @returns the mapping or null if not found/already consumed
   */
  public async consumeAuthCodeMapping(
    code: string,
  ): Promise<AuthCodeMapping | null> {
    const mapping = await this.findAuthCodeMapping(code);

    if (mapping) {
      this.#authCodeMappings.delete(code);
    }

    return mapping;
  }

  /**
   * finds a token mapping by hashed token.
   * @param tokenHash hash of the token
   * @returns the mapping or null if not found
   */
  public async findTokenMapping(
    tokenHash: string,
  ): Promise<TokenMapping | null> {
    const mapping = this.#tokenMappings.get(tokenHash);

    if (!mapping) {
      return null;
    }

    // check expiry if set
    if (mapping.expiresAt && Date.now() > mapping.expiresAt) {
      this.#tokenMappings.delete(tokenHash);

      return null;
    }

    return mapping;
  }

  /**
   * stores a token mapping.
   * @param tokenHash hash of the token
   * @param mapping the mapping data
   */
  public async upsertTokenMapping(
    tokenHash: string,
    mapping: TokenMapping,
  ): Promise<void> {
    this.#tokenMappings.set(tokenHash, mapping);
  }

  /**
   * deletes a token mapping.
   * @param tokenHash hash of the token
   */
  public async destroyTokenMapping(tokenHash: string): Promise<void> {
    this.#tokenMappings.delete(tokenHash);
  }

  /**
   * cleans up expired mappings.
   * @returns number of items cleaned up
   */
  public async cleanupExpired(): Promise<number> {
    const now = Date.now();
    let count = 0;

    // cleanup expired auth code mappings
    for (const [code, mapping] of this.#authCodeMappings) {
      if (now > mapping.expiresAt) {
        this.#authCodeMappings.delete(code);
        count++;
      }
    }

    // cleanup expired token mappings
    for (const [hash, mapping] of this.#tokenMappings) {
      if (mapping.expiresAt && now > mapping.expiresAt) {
        this.#tokenMappings.delete(hash);
        count++;
      }
    }

    return count;
  }
}
